#!/bin/bash

##
## electrumx bash client
##

ELECTRUMX_DEFAULT_HOSTS=("el0.veruscoin.io" "el1.veruscoin.io" "el2.veruscoin.io" "el3.veruscoin.io")

ELECTRUMX_CLIENT_NAME="0x03/electrumx-cli"
ELECTRUMX_PROTOCOL_VERSION="1.4"

# try to find ncat on the system, exit if not.
NCAT=$(which ncat)
if [ -z "${NCAT}" ]; then
    echo "\"ncat\" not found or not in \$PATH"
    echo "try: sudo apt install nmap"
    exit
fi

# try to find jq on the system, exit if not.
JQ=$(which jq)
if [ -z "${JQ}" ]; then
    echo "\"jq\" not found or not in \$PATH"
    echo "try: sudo apt install jq"
    exit
fi
JQ_OPTS="-Mr"

# try to find sleep on the system, exit if not.
SLEEP=$(which sleep)
if [ -z "${SLEEP}" ]; then
    echo "\"sleep\" not found or not in \$PATH"
    echo "try: find . -type 'f' -name '${SLEEP}'"
    exit
fi


# if theres a host set via environment variable H
if [ ! -z "${H}" ]; then
    # then use it
    ELECTRUMX_HOST="${H}"
else
    # otherwise select a random host from the ELECTRUMX_DEFAULT_HOSTS list above
    ELECTRUMX_HOST="${ELECTRUMX_DEFAULT_HOSTS[$RANDOM % ${#ELECTRUMX_DEFAULT_HOSTS[*]}]}"
fi

# if there is a port specified via environment variable P and it's numeric, use it
case ${P} in
    # empty or non-numeric, use default
    ''|*[!0-9]*)
        ELECTRUMX_PORT="17485"
    ;;
    *)
        # numeric, use passed value
        ELECTRUMX_PORT="${P}"
    ;;
esac

# position of module name in parameter list
MODULE="${1}"
# position of command specification in parameter list
COMMAND="${2}"

#
# electrumx helpers
#

# request data from electrumx
function _request(){
    # if there is a sleep duration specified via environment variable S and it's numeric, use it
    if [ ! -z "${S}" ]; then
        SLEEP_DURATION="${S}"
    else
        SLEEP_DURATION=0.5
    fi
    # save the first param which in the beginning is the method to execute
    METHOD="${1}"
    # remove it from the argument list
    shift 1

    # if there are still arguments left, 
    if [ $# -ge 1 ]; then 
        # start constructing 'params'
        PARAMS=",\"params\":["
        # while there are still arguments left
        while [ $# -ge 1 ]; do
            # add argument to 'params'
            PARAMS="${PARAMS}${1},"
            # remove argument from argument list
            shift
        done
        # since a PARAM will end in a , and that is bad for json, we'll remove
        # the last character from PARAMS and then close the array with a ]
        PARAMS="${PARAMS::-1}]"
    fi
    # request whatever has been prepared, with or without params.
    (echo "{\"id\": 1, \"method\": \"${METHOD}\"${PARAMS}}"; ${SLEEP} ${SLEEP_DURATION}) | ${NCAT} ${ELECTRUMX_HOST} ${ELECTRUMX_PORT}
}

# subscribe to data stream
function _subscribe(){
    if [ ! -z "${S}" ]; then
        SLEEP_DURATION="${S}"
    else
        SLEEP_DURATION=600
    fi
    # do the same thing again, now the first argument is the electrumx protocol method
    METHOD="${1}"
    shift

    # now, if any, we have only method arguments left. if so,
    if [ $# -ge 1 ]; then 
        # start constructing 'params'
        PARAMS=",\"params\":["
        # while there are still arguments left
        while [ $# -ge 1 ]; do
            # add argument to 'params'
            PARAMS="${PARAMS}${1},"
            # remove argument from argument list
            shift
        done
        # since a PARAM will end in a , and that is bad for json, we'll remove the last character from PARAMS.
        PARAMS="${PARAMS::-1}]"
    fi

    # subscribe to whatever has been prepared, for the given length, with or without params.
    (echo "{\"id\": 1, \"method\": \"${METHOD}\"${PARAMS}}"; ${SLEEP} ${SLEEP_DURATION}) | ${NCAT} ${ELECTRUMX_HOST} ${ELECTRUMX_PORT}
  }

#
# blockchain: chain_
#

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-block-header
# ${1}: height
function chain_header(){
    _request "blockchain.block.header" "${1}" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-block-headers
# ${1}: height
# ${2}: number
function chain_headers(){
    _request "blockchain.block.headers" "${1}" "${2}" | ${JQ} ${JQ_OPTS} .result

}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-estimatefee
# ${1}: target confirmations
function chain_estimatefee(){
    _request "blockchain.estimatefee" "${1}" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-relayfee
function chain_relayfee(){
    printf "%.8f\n" $(_request "blockchain.relayfee" | ${JQ} ${JQ_OPTS} .result)
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-headers-subscribe
# ${1}: duration in seconds, default 60
function chain_subscribe(){
    _subscribe "blockchain.headers.subscribe" | ${JQ} ${JQ_OPTS} ".result // .params"
}

# this just is 'blockchain.headers.subscribe' with a really short duration and a jq filter
function chain_height(){
    _request "blockchain.headers.subscribe" | ${JQ} ${JQ_OPTS} .result.height
}

#
# blockchain.scripthash: addr_
#

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-scripthash-get-balance
# ${1}: address
function addr_balance(){
	SCRIPTHASH=$(./scripthash ${1})
    RESULT=$(_request "blockchain.scripthash.get_balance" "\"${SCRIPTHASH}\"" | ${JQ} ${JQ_OPTS} .result.confirmed)
    echo "scale=8; ${RESULT}/100000000" | bc
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-scripthash-get-history
# ${1}: address
function addr_history(){
	SCRIPTHASH=$(./scripthash ${1})
    _request "blockchain.scripthash.get_history" "\"${SCRIPTHASH}\"" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-scripthash-get-mempool
# ${1}: address
function addr_mempool(){
	SCRIPTHASH=$(./scripthash ${1})
    _request "blockchain.scripthash.get_mempool" "\"${SCRIPTHASH}\"" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-scripthash-listunspent
# ${1}: address
function addr_unspent(){
	SCRIPTHASH=$(./scripthash ${1})
    _request "blockchain.scripthash.listunspent" "\"${SCRIPTHASH}\"" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-scripthash-subscribe
# ${1}: duration
# ${2}: address
function addr_subscribe(){
    SCRIPTHASH=$(./scripthash ${1})
    _subscribe "blockchain.scripthash.subscribe" "\"${SCRIPTHASH}\"" | ${JQ} ${JQ_OPTS} '.result // .params[1]// .error'
}

#
# blockchain.transaction: tx_
#

# todo: blockchain.transaction.broadcast
# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-transaction-broadcast

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-transaction-get
# 1: txid
# 2: verbose flag (hardcoded)
function tx_get(){
    _request "blockchain.transaction.get" "\"${1}\"" "1" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#blockchain-transaction-id-from-pos
# 1: height
# 2: pos
# 3: get response with merkle root (hardcoded)
function tx_get_pos(){
    _request "blockchain.transaction.id_from_pos" "${1}" "${2}" $(printf %.0f 1) | ${JQ} ${JQ_OPTS} .result
}

#
# mempool
#

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#mempool-get-fee-histogram
function mempool_get_fh(){
    _request "mempool.get_fee_histogram" | ${JQ} ${JQ_OPTS} .result
}

#
# server: srv_
#

# todo: server.add_peer
# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-add-peer


# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-banner
function srv_banner(){
    _request "server.banner" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-donation-address
function srv_donations(){
    _request "server.donation_address" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-features
function srv_features(){
    _request "server.features" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server.peers.subscribe
function srv_peers(){
    _request "server.peers.subscribe" | ${JQ} ${JQ_OPTS} .result
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-ping
function srv_ping(){
    REPLY=$(_request "server.ping" | ${JQ} ${JQ_OPTS} .result)
    if [ "${REPLY}" == "null" ]; then
        echo pong!
    fi
}

# https://electrumx.readthedocs.io/en/latest/protocol-methods.html#server-version
function srv_version(){
    _request "server.version" "\"${ELECTRUMX_CLIENT_NAME}\"" "\"${ELECTRUMX_PROTOCOL_VERSION}\"" | ${JQ} ${JQ_OPTS} .result[0]
}
function srv_protocol(){
    _request "server.version" "\"${ELECTRUMX_CLIENT_NAME}\"" "\"${ELECTRUMX_PROTOCOL_VERSION}\"" | ${JQ} ${JQ_OPTS} .result[1]
}

# execute
${MODULE}_${COMMAND} "${3}" "${4}" "${5}"

# EOF
